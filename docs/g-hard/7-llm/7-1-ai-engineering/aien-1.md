---
sidebar_position: 1
---

# 1, AI 엔지니어링:파운데이션 모델을 활용한 시스템 설계부터 개선까지 AI 앱 개발 원스톱 가이드

목차  
```
1장 파운데이션 모델을 활용한 AI 애플리케이션 입문
_1.1 AI 엔지니어링의 부상
__1.1.1 언어 모델에서 대규모 언어 모델로
__1.1.2 대규모 언어 모델에서 파운데이션 모델로
__1.1.3 파운데이션 모델에서 AI 엔지니어링으로
_1.2 파운데이션 모델 활용 사례
__1.2.1 코딩
__1.2.2 이미지 및 동영상 제작
__1.2.3 글쓰기
__1.2.4 교육
__1.2.5 대화형 봇
__1.2.6 정보 집계
__1.2.7 데이터 체계화
__1.2.8 워크플로 자동화
_1.3 AI 애플리케이션 기획
__1.3.1 활용 사례 평가
__1.3.2 기대치 설정
__1.3.3 마일스톤 계획
__1.3.4 유지보수
_1.4 AI 엔지니어링 스택
__1.4.1 AI의 세 가지 계층
__1.4.2 AI 엔지니어링 대 ML 엔지니어링
__1.4.3 AI 엔지니어링 대 풀스택 엔지니어링
_1.5 마치며

2장 파운데이션 모델 이해하기
_2.1 학습 데이터
__2.1.1 다국어 모델
__2.1.2 도메인 특화 모델
_2.2 모델링
__2.2.1 모델 아키텍처
__2.2.2 모델 크기
_2.3 사후 학습
__2.3.1 지도 파인튜닝
__2.3.2 선호도 파인튜닝
_2.4 샘플링
__2.4.1 샘플링의 기초
__2.4.2 샘플링 전략
__2.4.3 테스트 시점 연산
__2.4.4 구조화된 출력
__2.4.5 AI의 확률적 특성
_2.5 마치며

3장 평가 방법론
_3.1 파운데이션 모델 평가의 어려움
_3.2 언어 모델링 지표 이해하기
__3.2.1 엔트로피
__3.2.2 교차 엔트로피
__3.2.3 문자당 비트와 바이트당 비트
__3.2.4 퍼플렉시티
__3.2.5 퍼플렉시티 해석과 활용 사례
_3.3 정확한 평가
__3.3.1 기능적 정확성
__3.3.2 참조 데이터 유사도 측정
__3.3.3 임베딩 소개
_3.4 AI 평가자
__3.4.1 AI 평가자를 쓰는 이유
__3.4.2 AI 평가자 사용법
__3.4.3 AI 평가자의 한계
__3.4.4 평가자로 활용 가능한 모델
_3.5 비교 평가를 통해 모델 순위 정하기
__3.5.1 비교 평가의 과제들
__3.5.2 비교 평가의 미래
_3.6 마치며

4장 AI 시스템 평가하기
_4.1 평가 기준
__4.1.1 도메인 특화 능력
__4.1.2 생성 능력
__4.1.3 지시 수행 능력
__4.1.4 비용과 지연 시간
_4.2 모델 선택
__4.2.1 모델 선택 과정
__4.2.2 모델 자체 개발 대 상용 모델 구매
__4.2.3 공개 벤치마크 탐색하기
_4.3 평가 파이프라인 설계하기
__4.3.1 1단계: 시스템의 모든 구성 요소 평가하기
__4.3.2 2단계: 평가 가이드라인 만들기
__4.3.3 3단계: 평가 방법과 데이터 정의하기
_4.4 마치며

5장 프롬프트 엔지니어링
_5.1 프롬프트 소개
__5.1.1 인컨텍스트 학습: 제로샷과 퓨샷
__5.1.2 시스템 프롬프트와 사용자 프롬프트
__5.1.3 컨텍스트 길이와 컨텍스트 효율성
_5.2 프롬프트 엔지니어링 모범 사례
__5.2.1 명확하고 명시적인 지시 작성하기
__5.2.2 충분한 컨텍스트 제공하기
__5.2.3 복잡한 작업을 단순한 하위 작업으로 나누기
__5.2.4 모델에게 생각할 시간 주기
__5.2.5 프롬프트 반복하며 개선하기
__5.2.6 프롬프트 엔지니어링 도구 평가하기
__5.2.7 프롬프트 정리 및 버전 관리하기
_5.3 방어적 프롬프트 엔지니어링
__5.3.1 독점 프롬프트와 역 프롬프트 엔지니어링
__5.3.2 탈옥과 프롬프트 주입
__5.3.3 정보 추출
__5.3.4 프롬프트 공격에 대한 방어
_5.4 마치며

6장 RAG와 에이전트
_6.1 RAG
__6.1.1 RAG 아키텍처
__6.1.2 검색 알고리즘
__6.1.3 검색 최적화
__6.1.4 텍스트를 넘어선 RAG
_6.2 에이전트
__6.2.1 에이전트 개요
__6.2.2 도구
__6.2.3 계획 수립
__6.2.4 에이전트 실패 유형과 평가
_6.3 메모리
_6.4 마치며

7장 파인튜닝
_7.1 파인튜닝 개요
_7.2 파인튜닝이 필요한 경우
__7.2.1 파인튜닝을 해야 하는 이유
__7.2.2 파인튜닝을 하지 말아야 하는 이유
__7.2.3 파인튜닝과 RAG
_7.3 메모리 병목 현상
__7.3.1 역전파와 학습 가능한 파라미터
__7.3.2 메모리 계산
__7.3.3 수치 표현 방식
__7.3.4 양자화
_7.4 파인튜닝 기법
__7.4.1 파라미터 효율적 파인튜닝
__7.4.2 모델 병합과 다중 작업 파인튜닝
__7.4.3 파인튜닝 전술
_7.5 마치며

8장 데이터셋 엔지니어링
_8.1 데이터 큐레이션
__8.1.1 데이터 품질
__8.1.2 데이터 커버리지
__8.1.3 데이터 양
__8.1.4 데이터 수집과 주석
_8.2 데이터 증강 및 합성
__8.2.1 데이터 합성을 하는 이유
__8.2.2 전통적인 데이터 생성 기법
__8.2.3 AI 기반 데이터 합성
__8.2.4 모델 증류
_8.3 데이터 처리
__8.3.1 데이터 검사
__8.3.2 데이터 중복 제거
__8.3.3 데이터 정리 및 필터링
__8.3.4 데이터 형식 맞추기
_8.4 마치며

9장 추론 최적화
_9.1 추론 최적화 이해하기
__9.1.1 추론 개요
__9.1.2 추론 성능 지표
__9.1.3 AI 가속기
_9.2 추론 최적화
__9.2.1 모델 최적화
__9.2.2 추론 서비스 최적화
_9.3 마치며

10장 AI 엔지니어링 아키텍처와 사용자 피드백
_10.1 AI 엔지니어링 아키텍처
__10.1.1 1단계: 컨텍스트 보강
__10.1.2 2단계: 가드레일 도입하기
__10.1.3 3단계: 모델 라우터와 게이트웨이 추가
__10.1.4 4단계: 캐시로 지연 시간 줄이기
__10.1.5 5단계: 에이전트 패턴 추가
__10.1.6 모니터링과 관찰 가능성
__10.1.7 AI 파이프라인 오케스트레이션
_10.2 사용자 피드백
__10.2.1 대화형 피드백 추출
__10.2.2 피드백 설계
__10.2.3 피드백의 한계
_10.3 마치며  
```
