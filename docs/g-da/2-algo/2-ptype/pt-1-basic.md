---
sidebar_position: 1
---

# Basic    

- [Basic](#basic)
  - [⚠️ 중요, 문제 풀이 원칙](#️-중요-문제-풀이-원칙)
  - [시간복잡도 계산](#시간복잡도-계산)
  - [Boolean, Number](#boolean-number)


## ⚠️ 중요, 문제 풀이 원칙  

1.지문을 꼼꼼히 읽는다.  
- 놓치기 쉬운 조건들을 마킹한다.   
- 엣지 테스트 케이스를 찾는다.    
  - 시간복잡도/공간복잡도의 특이점    
  - 입력의 특이점  

2.코드를 작성하지 말고 로직을 기록한다.  
- 로직이 먼저 선행되어야 한다.   

3.그리고 코드를 작성한다.  


## 시간복잡도 계산 

```
1억번 연산 = 1초 

= 2**26 = 67108864 - 한계
= 2**27 = 134217728 

= 2**16 = 43046721 - 한계
= 3**17 = 129140163 

```

## Boolean, Number  

📌 결합 법칙, 교환 법칙

결합 법칙, 교환 법칙  
- XOR(⊕), AND(⋅), OR(+) 연산은 모두 교환 법칙과 결합 법칙이 성립    
- 교환 법칙 : 연산자 기준 변수를 앞뒤를 바꿔도 된다.  
    - eg) a ^ b ^ c ^ d ^ e 에서 뒤에서 4개만 먼저 앞으로 끌어올리가 가능.  
- 결합 법칙 : 연산자 기준 뒤에서 먼저 계산해도 된다.    
    - eg) a ^ b ^ c ^ d ^ e 에서 뒤에서 2개 먼저 계산, 앞에서 2개 먼저 계산, 그리고 나머지 계산해도 된다.    


📌 AND, OR, XOR 연산  

eg - https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/  

AND 연산의 의미  
```js
정확한 의미: 왼쪽부터 평가해서 Falsy 값을 만나면 즉시 그 Falsy 값을 반환하고, 더 이상 평가를 진행하지 않습니다. 모든 값이 Truthy라면, 마지막 값을 반환합니다.

의미1. Falsy 값을 골라내기 
- 왼쪽부터 평가해서 Falsy 값을 만나면 즉시 그 Falsy 값을 반환.
의미2. 전체가 Truthy 인가?  
- 모두 Truthy 값이라면 마지막 변수가 선택되니 전체가 Truthy가 된다.  

eg)
- 1 && 0 && 1 && 0 => 0
- 'h' && false && 100 => false
- 100 && 200 && 300 && 0 => 0  
- 'h' && 'e' && 'w' => 'w'  
- const loading = 1 && 0 && 1 && 0; // 로딩중 아님.  

```

OR 연산의 의미  
```js
정확한 의미: 왼쪽부터 평가해서 Truthy 값을 만나면 즉시 그 Truthy 값을 반환하고, 더 이상 평가를 진행하지 않습니다. 모든 값이 Falsy라면, 마지막 값을 반환합니다.

의미1. Truthy 값을 골라내기     
- 왼쪽부터 평가해서 Truthy 값을 만나면 즉시 그 Truthy 값을 반환 후 평가 중단.   

의미2. 하나라도 Truthy 인가?  
- 의미1의 반환값에 의해 사용.  

의미3. 전체가 Falsy가 인가?  
- 모두 Falsy 값이라면 마지막 변수가 선택된다. 그래서 전체가 Falsy가 된다.  
- 의미2가 아닌 경우.  

eg)
- 1 || 0 || 1 || 0 => 1
- false || 'h' || 100 => 'h'
- 0 || 100 || 200 || 300  => 100  
- 'h' || 'e' || 'w' => 'h' 
- undefined || '0' => '0'  
- const initValue = undefined || '10' // 적어도 '10'은 보장  
```

XOR 논리 연산 의미 
```js
// XOR 논리 비트 의미 
의미 1. 두 명제 중 오직 하나만 참일 때 참(True)을 반환  

- 두 비트가 다르면 1, 같으면 0을 결과 비트에 써서 리턴  
5 = 0101 (이진수)
3 = 0011 (이진수) 
0101 ^ 0011 = 0110 (이진수)  
0110 = 6 (십진수)   

// XOR 논리 연산 +비트 의미 
의미 2. 0은 보존, 1은 상쇄  
- 0 ^ 5 = 5 ( 000 ^ 101 => 101 ) => 보존
- 5 ^ 5 = 0 ( 111 ^ 111 => 000 ) => 상쇄

의미 3. 매핑이 없는 변수 반환  
- 1 ^ 1 ^ 5 ^ 2 ^ 2 = 1과 2는 모두 짝이 존재한다. 5는 짝이 없다.  

1 ^ 1 ^ 5 ^ 2 ^ 2 (교환법칙에 의해 위치 변경 가능)
= 1 ^ 1 ^ 2 ^ 2 ^ 5 (결합법칙에 의해 앞에서 먼저 계산 가능)
= 0 ^ 5 (XOR의 보존에 의해 5 반환 )
= 5  

```
