---
sidebar_position: 1
---

# Basic    

- [Basic](#basic)
  - [⚠️ 중요, 문제 풀이 원칙](#️-중요-문제-풀이-원칙)
  - [시간복잡도 계산](#시간복잡도-계산)
  - [Boolean, Number](#boolean-number)
  - [문제를 이해하는 틀](#문제를-이해하는-틀)


## ⚠️ 중요, 문제 풀이 원칙  

1.지문을 꼼꼼히 읽는다.  
- 놓치기 쉬운 조건들을 마킹한다.   
- 엣지 테스트 케이스를 찾는다.    
  - 시간복잡도/공간복잡도의 특이점    
  - 입력의 특이점  

2.코드를 작성하지 말고 로직을 기록한다.  
- 로직이 먼저 선행되어야 한다.   

3.그리고 코드를 작성한다.  


## 시간복잡도 계산 

빅오 표기법으로 접근한다.  
- 시간 복잡도는 1초 이내 해결할 수 있어야한다. 이는 10**8 (10의 8승) 이내로 끊어야 함  
- 내가 짠 알고리즘이 O(N)이라면 N이 <= 10**8 이어야 한다.  

일반적인 알고리즘 문제(시간 제한 1초, 약 10^8 연산) 기준으로 N의 근사 최댓값:
- **O(N)**: 10^8 이하
- **O(NlogN)**: 약 10^6 이하 (N·log₂N ≈ 10^6·20 ≈ 2·10^7)
- **O(N²)**: 약 10^4 이하 (N² = (10^4)² = 10^8)
- **O(N³)**: 약 500 이하 (약 5·10^2, 500³ ≈ 1.25·10^8)
- **O(2^N)**: 약 25 이하 (2^25 ≈ 3.4·10^7)
- **O(3^N)**: 약 16 이하 (3^16 ≈ 4.3·10^7)



## Boolean, Number  

📌 결합 법칙, 교환 법칙

결합 법칙, 교환 법칙  
- XOR(⊕), AND(⋅), OR(+) 연산은 모두 교환 법칙과 결합 법칙이 성립    
- 교환 법칙 : 연산자 기준 변수를 앞뒤를 바꿔도 된다.  
    - eg) a ^ b ^ c ^ d ^ e 에서 뒤에서 4개만 먼저 앞으로 끌어올리가 가능.  
- 결합 법칙 : 연산자 기준 뒤에서 먼저 계산해도 된다.    
    - eg) a ^ b ^ c ^ d ^ e 에서 뒤에서 2개 먼저 계산, 앞에서 2개 먼저 계산, 그리고 나머지 계산해도 된다.    


📌 AND, OR, XOR 연산  

eg - https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/  

AND 연산의 의미  
```js
정확한 의미: 왼쪽부터 평가해서 Falsy 값을 만나면 즉시 그 Falsy 값을 반환하고, 더 이상 평가를 진행하지 않습니다. 모든 값이 Truthy라면, 마지막 값을 반환합니다.

의미1. Falsy 값을 골라내기 
- 왼쪽부터 평가해서 Falsy 값을 만나면 즉시 그 Falsy 값을 반환.
의미2. 전체가 Truthy 인가?  
- 모두 Truthy 값이라면 마지막 변수가 선택되니 전체가 Truthy가 된다.  

eg)
- 1 && 0 && 1 && 0 => 0
- 'h' && false && 100 => false
- 100 && 200 && 300 && 0 => 0  
- 'h' && 'e' && 'w' => 'w'  
- const loading = 1 && 0 && 1 && 0; // 로딩중 아님.  

```

OR 연산의 의미  
```js
정확한 의미: 왼쪽부터 평가해서 Truthy 값을 만나면 즉시 그 Truthy 값을 반환하고, 더 이상 평가를 진행하지 않습니다. 모든 값이 Falsy라면, 마지막 값을 반환합니다.

의미1. Truthy 값을 골라내기     
- 왼쪽부터 평가해서 Truthy 값을 만나면 즉시 그 Truthy 값을 반환 후 평가 중단.   

의미2. 하나라도 Truthy 인가?  
- 의미1의 반환값에 의해 사용.  

의미3. 전체가 Falsy가 인가?  
- 모두 Falsy 값이라면 마지막 변수가 선택된다. 그래서 전체가 Falsy가 된다.  
- 의미2가 아닌 경우.  

eg)
- 1 || 0 || 1 || 0 => 1
- false || 'h' || 100 => 'h'
- 0 || 100 || 200 || 300  => 100  
- 'h' || 'e' || 'w' => 'h' 
- undefined || '0' => '0'  
- const initValue = undefined || '10' // 적어도 '10'은 보장  
```

XOR 논리 연산 의미 
```js
// XOR 논리 비트 의미 
의미 1. 두 명제 중 오직 하나만 참일 때 참(True)을 반환  

- 두 비트가 다르면 1, 같으면 0을 결과 비트에 써서 리턴  
5 = 0101 (이진수)
3 = 0011 (이진수) 
0101 ^ 0011 = 0110 (이진수)  
0110 = 6 (십진수)   

// XOR 논리 연산 +비트 의미 
의미 2. 0은 보존, 1은 상쇄  
- 0 ^ 5 = 5 ( 000 ^ 101 => 101 ) => 보존
- 5 ^ 5 = 0 ( 111 ^ 111 => 000 ) => 상쇄

의미 3. 매핑이 없는 변수 반환  
- 1 ^ 1 ^ 5 ^ 2 ^ 2 = 1과 2는 모두 짝이 존재한다. 5는 짝이 없다.  

1 ^ 1 ^ 5 ^ 2 ^ 2 (교환법칙에 의해 위치 변경 가능)
= 1 ^ 1 ^ 2 ^ 2 ^ 5 (결합법칙에 의해 앞에서 먼저 계산 가능)
= 0 ^ 5 (XOR의 보존에 의해 5 반환 )
= 5  

```


## 문제를 이해하는 틀  

1.사물 이해, 정의 파악, 범위 파악      
- 예, N개의 루프의 셋트 ( 문제내 존재하는 사물 )  
- 정의  
  - A : 세그먼트의 head position을 담은 배열, B : tail position을 담은 배열  
  - A[i] : i번째 세그먼트의 head position
  - i : 세그먼트 번호 
  - 오버랩된 루프 : position이 같거나 겹치는 경우를  
  - 루프 셋 : 1개 이상의 루프의 집합  
- 범위  
  - N 루프 수 : 0~30,000개 
  - 포지션 : 0..1,000,000,000  
  - A[I] ≤ B[I], for each I (0 ≤ I < N); : head <= tail   
  - B[K] ≤ B[K + 1], for each K (0 ≤ K < N − 1) :  tail <= next tail  


